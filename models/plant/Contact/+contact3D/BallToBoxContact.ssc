component BallToBoxContact
% Ball To Box 3D Contact

inputs
    R = zeros(3); % R:left
    wx = { 0,'rad/s'}; % wx:left
    wy = { 0,'rad/s'}; % wy:left
    wz = { 0,'rad/s'}; % wz:left
    x = { 0, 'm' }; % x:left
    y = { 0, 'm' }; % y:left
    z = { 0, 'm' }; % z:left
    vx = { 0, 'm/s' }; % vx:left
    vy = { 0, 'm/s' }; % vy:left
    vz = { 0, 'm/s' }; % vz:left
end

variables
        F = {[0;0;0], 'N'};
    end
    
  outputs
    FWheel = { [0;0;0] , 'N' }; % fw:right
    TWheel = { [0;0;0] , 'N*m' }; %tw:right
    FBlock = { [0;0;0] , 'N' }; % fb:right
    TBlock = { [0;0;0] , 'N*m' }; %tb:right
  end

  parameters
    rWheel = { 1, 'm' }; % radius
    xBlock = { 2, 'm' }; % Block X [m]
    yBlock = { 3, 'm' }; % Block Y [m]
    zBlock = { 0.2, 'm' }; % Block Z [m]
    k = { 2500, 'N/m' }; % Contact Stiffness
    b = { 100, 'N*s/m'}; % Contact Damping
    b2 = { 1000, 'N*s/m'}; % Slip Damping
  end

  equations
      let
          
          
        % LOGICAL STUFF
        aboveLowerX = x > -(rWheel + xBlock/2);
        belowUpperX = x < rWheel + xBlock/2;
        insideX = (x<xBlock/2) && (x>-xBlock/2);

        aboveLowerY = y > -(rWheel + yBlock/2);
        belowUpperY = y < rWheel + yBlock/2;
        insideY = (y<yBlock/2) && (y>-yBlock/2);

        aboveLowerZ = z > -(rWheel + zBlock/2);
        belowUpperZ = z < rWheel + zBlock/2;
        insideZ = (z<zBlock/2) && (z>-zBlock/2);

        % CORNER STUFF
%         theta = atan2(z-zBlock/2,y-yBlock/2);
%         deltaZ = z - rWheel*sin(theta) - zBlock/2;

% [fxt, tx] = if (insideY && belowUpperX && aboveLowerX),...
%         if abs(x-(r+w/2)) < abs(x+(r+w/2)),...
%             -k*(x - (r+w/2)) - b*vx;...
%             -b*(vy-omega*r)*r...
%         else...
%             -k*(r+w/2 + x) - b*vx;...
%             b*(vy-omega*r)*r...
%         end...
%       else...
%         {0,'N'};{0,'N*m'}...
%       end;
% 
% 
% [fyt, ty] = if (insideX && belowUpperY && aboveLowerY),...
%         if abs(y-(r+h/2)) < abs(y+(r+h/2)),...
%             -k*(y - (r+h/2)) - b*vy;...
%             -b*(vx-omega*r)*r...
%         else...
%             -k*(r+h/2 + y) - b*vy;...
%             b*(vx-omega*r)*r...
%         end...
%       else...
%         {0,'N'};{0,'N*m'}...
%       end;

%            % X direction
%         if insideY && insideZ && belowUpperX && aboveLowerX
%                 % Approaching from upper
%                 if abs(x-(rWheel+xBlock/2)) < abs(x+(rWheel+xBlock/2))
%                     fx = -k*(x - (rWheel+xBlock/2)) - b*vx;          
%                 % Approaching from lower
%                 else
%                     fx = -k*(rWheel+xBlock/2 + x) - b*vx;
%                 end
%         end
% 


        % Z direction
        % NORMAL
        [fx,fy,fz,tx,ty,tz,dir] = ...
            if insideX && insideY && belowUpperZ && aboveLowerZ, ...
                % Approaching from upper
                if abs(z-(rWheel+zBlock/2)) < abs(z+(rWheel+zBlock/2)), ...
                    {0,'N'};...
                    {0,'N'};...
                    -k*(z - (rWheel+zBlock/2)) - b*vz;...
                    -b2*(vy + wx*rWheel)*rWheel;...
                    -b2*(vx + wy*rWheel)*rWheel;...
                    {0,'N*m'};...
                    1;
                % Approaching from lower
                else...
                    {0,'N'};...
                    {0,'N'};...
                    -k*(rWheel+zBlock/2 + z) - b*vz;...
                    -b2*(-vy + wx*rWheel)*rWheel;...
                    -b2*(-vx + wy*rWheel)*rWheel;...
                    {0,'N*m'};...
                    -1;
                end...        
            % UPPER RIGHT CORNER
            else...
                 if (insideX && ((y-yBlock/2)^2 + (z-zBlock/2)^2) < rWheel^2 ),...         
%                 theta = atan2(z-zBlock/2,y-yBlock/2);
%                 deltaZ = z - rWheel*sin(theta) - zBlock/2;
%                 fz = -k*deltaZ - b*vz;
%                 fy = fz/tan(theta);...
                  {0,'N'};...
                  (-k*(z - rWheel*sin(atan2(z-zBlock/2,y-yBlock/2)) - zBlock/2) - b*vz)/((z-zBlock/2)/(y-yBlock/2));...
                  -k*(z - rWheel*sin(atan2(z-zBlock/2,y-yBlock/2)) - zBlock/2) - b*vz; ...  
                  -b2*(vy + wx*rWheel)*rWheel;...
                  -b2*(vx + wy*rWheel)*rWheel;...
                  {0,'N*m'};...
                  1;
                  else...
                    % UPPER LEFT CORNER
                    if (insideX && ((y+yBlock/2)^2 + (z-zBlock/2)^2) < rWheel^2 ),...          
%                         theta = atan2(z-zBlock/2,y+yBlock/2);...
%                         deltaZ = z - rWheel*sin(theta) - zBlock/2;...
%                         fz = -k*deltaZ - b*vz;...
%                         fy = fz/tan(theta);...
                      {0,'N'};...
                      (-k*(z - rWheel*sin(atan2(z-zBlock/2,y+yBlock/2)) - zBlock/2) - b*vz)/((z-zBlock/2)/(y+yBlock/2));...
                      -k*(z - rWheel*sin(atan2(z-zBlock/2,y+yBlock/2)) - zBlock/2) - b*vz; ...   
                      -b2*(vy + wx*rWheel)*rWheel;...
                      -b2*(vx + wy*rWheel)*rWheel;...
                      {0,'N*m'};...
                      1;
                    else...
                       % Y direction
                       if insideX && insideZ && belowUpperY && aboveLowerY; ...
%                          % Approaching from upper
                           if abs(y-(rWheel+yBlock/2)) < abs(y+(rWheel+yBlock/2)),...
                               {0,'N'};...
                               -k*(y-(rWheel+yBlock/2)) - b*vy;...
                               {0,'N'};...   
                               {0,'N*m'};...
                               {0,'N*m'};...
                               {0,'N*m'};...
                               1;
%                          % Approaching from lower
                           else...
                               {0,'N'};...  
                               -k*(rWheel+yBlock/2 + y) - b*vy;...
                               {0,'N'};...   
                               {0,'N*m'};...
                               {0,'N*m'};...
                               {0,'N*m'};...
                               -1;
                           end
                       else...
                           {0,'N'};{0,'N'};{0,'N'};{0,'N*m'};{0,'N*m'};{0,'N*m'};0;...
                       end...
                    end...
                 end...
            end;

      in
         

%           % Force and torque to be applied to the ball
%           F_ball == R'*[fxt + ty/r; fyt + tx/r;{0,'N'}];
%           T_ball == R'*[{0,'N*m'};{0,'N*m'};tx+ty];
%           % force and torque to be applied to the box
%           F_box == -[fxt + ty/r; fyt + tx/r;{0,'N'}];
%           T_box == [{0,'N*m'};{0,'N*m'}; tx+ty + -x*(fyt + tx/r) - (y*(-(fxt + ty/r)))];

          F == [fx + dir*(ty+tz)/rWheel; ...
                fy + dir*(tx+tz)/rWheel;  ...
                fz + dir*(tx+ty)/rWheel];
          FWheel == R*F;
          TWheel == R*[tx ; ty ; tz];
          FBlock == -[fx;fy;fz];
          TBlock == [-y*fz+z*fy ; x*fz-z*fx ; -x*fy+y*fx];

      end
  end

end
